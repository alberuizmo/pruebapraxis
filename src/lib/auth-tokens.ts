/**
 * Auth Token Management
 * 
 * PRODUCTION SECURITY PATTERN:
 * - Access tokens: Short-lived (15 min) for API requests
 * - Refresh tokens: Would be stored in httpOnly cookies (not accessible via JS)
 * - HTTPS only in production
 * - Token rotation on each refresh
 * 
 * For this demo, we simulate JWT tokens with expiration.
 * In real production:
 * - Tokens would be generated by backend (HS256/RS256)
 * - Refresh endpoint would return new access token
 * - Sensitive data NEVER stored in client storage
 */

import type { AuthToken, TokenPayload } from '@/types';
import { AUTH } from '@/constants';

const TOKEN_KEY = AUTH.SESSION_STORAGE_KEY;
const TOKEN_DURATION = AUTH.TOKEN_EXPIRATION_MS;

// Simulate JWT token generation (in production, backend does this)
function generateToken(userId: string, email: string, role: string): AuthToken {
    const now = Date.now();
    const expiresAt = now + TOKEN_DURATION;
    
    // Simulate JWT payload (in production: jwt.sign())
    const payload: TokenPayload = {
        userId,
        email,
        role,
        iat: now,
        exp: expiresAt
    };
    
    // In production, this would be: jwt.sign(payload, SECRET_KEY)
    // For demo, we just base64 encode (NOT SECURE - only for simulation)
    const accessToken = btoa(JSON.stringify(payload));
    
    return { accessToken, expiresAt, userId };
}

// Decode and validate token
function decodeToken(token: string): TokenPayload | null {
    try {
        // In production: jwt.verify(token, SECRET_KEY)
        const payload = JSON.parse(atob(token)) as TokenPayload;
        
        // Check expiration
        if (Date.now() >= payload.exp) {
            return null; // Token expired
        }
        
        return payload;
    } catch {
        return null;
    }
}

export const TokenManager = {
    create: (userId: string, email: string, role: string): AuthToken => {
        const token = generateToken(userId, email, role);
        
        try {
            // Store only the token, NOT sensitive user data
            sessionStorage.setItem(TOKEN_KEY, JSON.stringify(token));
        } catch {
            // Graceful fallback for environments without sessionStorage
        }
        
        return token;
    },
    
    get: (): AuthToken | null => {
        try {
            const stored = sessionStorage.getItem(TOKEN_KEY);
            if (!stored) return null;
            
            const token = JSON.parse(stored) as AuthToken;
            
            // Validate token is not expired
            if (Date.now() >= token.expiresAt) {
                TokenManager.clear();
                return null;
            }
            
            return token;
        } catch {
            return null;
        }
    },
    
    decode: (token: string): TokenPayload | null => {
        return decodeToken(token);
    },
    
    isValid: (): boolean => {
        const token = TokenManager.get();
        if (!token) return false;
        
        // Additional validation
        const payload = decodeToken(token.accessToken);
        return payload !== null;
    },
    
    clear: (): void => {
        try {
            sessionStorage.removeItem(TOKEN_KEY);
        } catch {
            // Ignore errors
        }
    },
    
    // Simulate token refresh (in production, calls /api/auth/refresh)
    // In real app, this would use refresh token from httpOnly cookie
    refresh: async (): Promise<AuthToken | null> => {
        const currentToken = TokenManager.get();
        if (!currentToken) return null;
        
        const payload = decodeToken(currentToken.accessToken);
        if (!payload) return null;
        
        // Simulate API call delay
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Generate new token
        return TokenManager.create(payload.userId, payload.email, payload.role);
    }
};